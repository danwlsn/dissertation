This chapter will discuss the development stage of the production of the progress monitoring web application. It will cover a number of topics, from development tools used during this stage to development methods uses whilst building this application. It will also walk through, step by step, of the building process highlighting problems and how they were overcome.\\

\subsection{Tools}
A number of tools were used during development, some were used more and others but all of them played a key role in development. The main tool that was used is Sublime Text 2 \citep{sublimetext:2011}. This was the text editor that was used to build both the static mock up of the site and the full functioning web application. Sublime Text was chosen because of it's vast amount of plugins. This makes it very versatile and efficient when it comes to building productions applications. There were a number of other editors considered for the job, for example; Vim \citep{vim:2013} was going to be chosen on due to its rapid development capabilities from all of the navigation being done on the keyboard. But it was not chased due to the steep learning curve as this would eat into development time. The time investment into learning Vim would probably not be beneficial to such a small project but will be a consideration for future projects. During the development of the static site, a JavaScript task runner called Grunt. It was used to compile Sass, minify javaScript, and optimise images. When development moved onto Rails it was dropped as Rails compiles Sass and minifies JavaScript in the assists pipeline. The second main tool that was used was iTerm 2 \citep{iterm:2011} using the oh-my-zsh \citep{zsh:2009}. Using the command when building a Ruby on Rails application is absolutely necessary. It's used to generate controllers and models, start the Rails server, interact with the database, and a number of other key features. The terminal emulator is not really that important but the use of the Zsh shell was very useful to the development stage. It has a number of excellent features like displaying the current Git \citep{git:2014} branch that I was working in and if there was any changes that haven't been committed and also highlighting in the terminal. Seeing as a lot of the time was spent in the terminal, it was important to make that time as productive and as efficient as possible. Git was another tool that really helped with development. Git is a version control application which allows the user to commit versions of code so that it would be easy to revert back to a previous version of code if something went wrong with development. A slightly adapted branching methodology was used called Gitflow which allowed easier version control during development and having a live and stable master branch that could be used to push to Heroku. Heroku was used to host the site, more information on this service can be found in the deployment section \ref{sec:deployment} of this chapter on page \pageref{sec:deployment}. An application called Dash was also used during development. Dash allows you to download documentation for certain languages and frameworks and stores it offline. It allowed the Rails documentation to always be readily available whenever.

\subsection{Development Log}
Development began ahead of schedule because designs were already done. Even though not all the designs had been done, the essentials were there, it was only separate pages that were missing. The colour scheme, font choice, and general feel were all there so development got started with the static HTML being built. Using Grunt and sublime made getting out a static site very quick and easy. This stage did not take as long as I had originally planned. It was done within three days, where as originally it was to take two weeks. However, design has not being fully completed, what is commonly known as "designing in the browser" took place. This is where a rough idea of what the page is to look like is in the developer head and they just design it in HTML and CSS straight away, without going through the step by step process of wire framing and mock ups. While this is not a good idea on large scale project, the minimalist design that the application was adopted made it almost easier to design in the browser than draw wireframes and create mock ups.\\

Once the static site had been generated and the designs had been finalised it was straight into Rails development. The develop was split up into features and each feature was implemented separate. This allowed deadlines to be made so it was easy to track the progress and see if development was on track. The features that were split up were;

\begin{enumerate}
\item A user system with the ability to create a new user and login and out
\item Weight tracking, for both current and goal weights
\item Fitness log
\item Goal tracking
\end{enumerate}

\noindent
Once these deadlines were confirmed, development could properly begin.\\

Not much knowledge was known about Ruby on Rails was known before development, other than some basic syntax and that it's an MVC framework. So at first, the approach was to learn and build at the same time. This lead to two things and the first problem; it was very slow and the code was getting sloppy. This type of development style didn't last very long when development came to a stand still when trying to implement the weight tracking. The decision was made to halt development and take the time to learn some Rails.\\

Two main sources for learning rails were used. The first one was a tutorial by Marc Someone. This tutorial took you through making a Twitter clone. It was useful because it went through how to create a authentication/authorisation system, create relationships between the user and other models, and also some test driven development. The second was the Rails tutorials. These covered pretty much all parts of Rails so they were referred to as and when there was a problem that couldn't be solved by referring to the documentation. The Rails Documentation was also referred to a lot during development.\\

After a firm understanding of Rails was gained, development could continue. The downside to this break meant that development was now far behind schedule. As development went on though, it caught itself up. The learning break was worth it because development began to speed up and the code that was being produced was to a higher standard.\\

So far, only the user system had been implemented and it was time to move on to the weight tracking. This was were the problem of not knowing enough Rails to continue arose, which was solved with taking the time to learn it instead of learning as development went on. So when it was time to come back to it, all the weight tracking code that was used prior to learning Rails was removed. This was made easy with Git. Git allows you to reset changed to a certain commit. The code was rolled back to where the user system was just finished and so was the Rails database. For the weight tracking, two separate models were used. Originally, the goal weight was going to inside the user model but the decision was to split it off was so that it could possibly used for future analysis. For example; plotting a graph for both the users weight and their goal weights against time so they will be able to see when they hit their goals. This also lead to splitting up the goal weight and the current weight into tables. Another factor into this was the thought that user will be updating their current weight much more than their goal weight. So to have them in the same table would lead to multiple duplicate goal weights. These weight were to be shown on the dashboard and updated through a different page. In the original design, there was going to be a little graph under where the weights are displayed on the dashboard. This idea was removed because of how small the graph would be. It was moved to the weight input page so that it could be a lot bigger and the user would be able to gain more information from it. The weight input screen was kept really simple. It has two input boxes and two submit buttons, one for the goal weight and one for the current. Rails allows for very simple AJAX integration with forms. AJAX allows the user to update the database without having to leave the current page. This will allow the user to update their weights and then consult the graph without having to load the page again. It will be a great help on mobiles where the connection may not be great.\\

 

\subsection{Deployment}
\label{sec:deployment}
Deployment of the web application was done through a service called Heroku. It offers a free hosting services for small application but will automatically scale up when demand for the website rises. This was perfect for the application as it was easy to get a prototype on the web quickly but if demand for the website rose then Heroku would scale up my application to match the demand. It was also chosen for its ease of use. It ties in well with Git and just creates a new remote in your local repository to push to. It will thens detect what type of application is being deployed, a Rails application in this case, and do all the setting up necessary to a Rails application. The only setup needed on our end was a few changes to the gem file. Adding a production and development group to switch between a MySQL for local testing and PostGre database for Heroku, and adding the Git remote which was made simple with the Heroku tool belt. Heroku also has the option to allow to assign your own domain to it.\\

Other options were to deploy to a virtual Private server using the Capistrano gem. This was the original idea but after discovering Heroku it seemed slightly overkill. Also, with Ruby applications, dependences have to match up, other wise your application will not run. While you can force gem versions in the gem file, Heroku manages all that for you.
