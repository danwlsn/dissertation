This chapter will discuss the development stage of the production of the progress monitoring web application. It will cover a number of topics, from development tools used during this stage to development methods uses whilst building this application. It will also walk through, step by step, of the building process highlighting problems and how they were overcome.\\

\subsection{Tools}
A number of tools were used during development, some were used more and others but all of them played a key role in development. The main tool that was used is Sublime Text 2 \citep{sublimetext:2011}. This was the text editor that was used to build both the static mock up of the site and the full functioning web application. Sublime Text was chosen because of it is vast amount of plugins. This makes it very versatile and efficient when it comes to building productions applications. There were a number of other editors considered for the job, for example; Vim \citep{vim:2013} was going to be chosen on due to its rapid development capabilities from all of the navigation being done on the keyboard. But it was not chased due to the steep learning curve as this would eat into development time. The time investment into learning Vim would probably not be beneficial to such a small project but will be a consideration for future projects. During the development of the static site, a JavaScript task runner called Grunt. It was used to compile Sass \citep{sass:2006}, minify javaScript, and optimise images. When development moved onto Rails it was dropped as Rails compiles Sass and minifies JavaScript in the assists pipeline. The second main tool that was used was iTerm 2 \citep{iterm:2011} using the oh-my-zsh \citep{zsh:2009}. Using the command when building a Ruby on Rails application is absolutely necessary. It is used to generate controllers and models, start the Rails server, interact with the database, and a number of other key features. The terminal emulator is not really that important but the use of the Zsh shell was very useful to the development stage. It has a number of excellent features like displaying the current Git \citep{git:2014} branch that I was working in and if there was any changes that have not been committed and also highlighting in the terminal. Seeing as a lot of the time was spent in the terminal, it was important to make that time as productive and as efficient as possible. Git was another tool that really helped with development. Git is a version control application which allows the user to commit versions of code so that it would be easy to revert back to a previous version of code if something went wrong with development. A slightly adapted branching methodology was used called Gitflow \citep{gitflow:2010} which allowed easier version control during development and having a live and stable master branch that could be used to push to Heroku. Heroku \citep{heroku:2007} was used to host the site, more information on this service can be found in the deployment section \ref{sec:deployment} of this chapter on page \pageref{sec:deployment}. An application called Dash \citep{dash:2014} was also used during development. Dash allows you to download documentation for certain languages and frameworks and stores it offline. It allowed the Rails documentation to always be readily available whenever.

\subsection{Gems}
!!Description of what a Gem is and how it is useful!! A number of other Gems were used during development, along side the default Rails Gems. The bcrypt-ruby gem was used for user creation and authentication. It allows you to create a password digest for storing in the user\'s record using one way encryption. This makes the system a lot more secure than storing the password in plain text, or even using a salt and hash to store the password. Sass-rails was used so that the style sheets could be writing in Sass and compile to CSS at build time. Sass is has a number of benefits over vanilla CSS, like being able to use variables for colours to allow for easier mass colour change. Better errors gem was also used during development to give a more in-depth error message when something went wrong. The default Rails error message is as descriptive as the better errors Gem so it becomes a lot easier to debug the application.

\subsection{Development Log}
Development began ahead of schedule because designs were already done. Even though not all the designs had been done, the essentials were there, it was only separate pages that were missing. The colour scheme, font choice, and general feel were all there so development got started with the static HTML being built. Using Grunt \citep{grunt:2013} and sublime made getting out a static site very quick and easy. This stage did not take as long as I had originally planned. It was done within three days, where as originally it was to take two weeks. However, design has not being fully completed, what is commonly known as designing in the browser took place. This is where a rough idea of what the page is to look like is in the developer head and they just design it in HTML and CSS straight away, without going through the step by step process of wire framing and mock ups. While this is not a good idea on large scale project, the minimalist design that the application was adopted made it almost easier to design in the browser than draw wireframes and create mock ups.\\

Once the static site had been generated and the designs had been finalised it was straight into Rails development. The develop was split up into features and each feature was implemented separate. This allowed deadlines to be made so it was easy to track the progress and see if development was on track. The features that were split up were;

\begin{enumerate}
\item A user system with the ability to create a new user and login and out
\item Weight tracking, for both current and goal weights
\item Fitness log
\item Goal tracking
\end{enumerate}

\noindent
Once these deadlines were confirmed, development could properly begin.\\

Not much knowledge was known about Ruby on Rails was known before development, other than some basic syntax and that it is an MVC framework. So at first, the approach was to learn and build at the same time. This lead to two things and the first problem; it was very slow and the code was getting sloppy. This type of development style did not last very long when development came to a stand still when trying to implement the weight tracking. The decision was made to halt development and take the time to learn some Rails.\\

Two main sources for learning rails were used. The first one was a tutorial by Marc Someone. This tutorial took you through making a Twitter \citep{twitter:2006} clone. It was useful because it went through how to create a authentication/authorisation system, create relationships between the user and other models, and also some test driven development. The second was the Rails tutorials. These covered pretty much all parts of Rails so they were referred to as and when there was a problem that could not be solved by referring to the documentation. The Rails Documentation was also referred to a lot during development.\\

After a firm understanding of Rails was gained, development could continue. The downside to this break meant that development was now far behind schedule. As development went on though, it caught itself up. The learning break was worth it because development began to speed up and the code that was being produced was to a higher standard.\\

So far, only the user system had been implemented and it was time to move on to the weight tracking. This was were the problem of not knowing enough Rails to continue arose, which was solved with taking the time to learn it instead of learning as development went on. So when it was time to come back to it, all the weight tracking code that was used prior to learning Rails was removed. This was made easy with Git. Git allows you to reset changed to a certain commit. The code was rolled back to where the user system was just finished and so was the Rails database. For the weight tracking, two separate models were used. Originally, the goal weight was going to inside the user model but the decision was to split it off was so that it could possibly used for future analysis. For example; plotting a graph for both the users weight and their goal weights against time so they will be able to see when they hit their goals. This also lead to splitting up the goal weight and the current weight into tables. Another factor into this was the thought that user will be updating their current weight much more than their goal weight. So to have them in the same table would lead to multiple duplicate goal weights. These weight were to be shown on the dashboard and updated through a different page. In the original design, there was going to be a little graph under where the weights are displayed on the dashboard. This idea was removed because of how small the graph would be. It was moved to the weight input page so that it could be a lot bigger and the user would be able to gain more information from it. The weight input screen was kept really simple. It has two input boxes and two submit buttons, one for the goal weight and one for the current. Rails allows for very simple AJAX integration with forms. AJAX allows the user to update the database without having to leave the current page. This will allow the user to update their weights and then consult the graph without having to load the page again. It will be a great help on mobiles where the connection may not be great.\\

Once the weight tracking was implemented it was on to the next feature which is the fitness log. The fitness log is its own table which consists of six fields:

\begin{enumerate}
\item Activity - The name of the exercise
\item Type - What type of exercise (strength, cardio)
\item Time - How long the user spent doing the exercise
\item Reps - How many repetitions the user did
\item Sets - How many sets the user did
\item Weight - How heavy the weight was
\end{enumerate}

There are two main types of exercises; strength and cardio. There were two options when it came to storing this information. Option one was to have three tables; fitness log, cardio, and strength. The fitness log would just store the user\'s ID and the ID of either a cardio entry or a strength entry. Or option two which is to have them all one table and use some logic in the controller and view to determine what to do with the data dependant upon whether it is a strength exercise or a cardio exercise. The reason for needing to either split them up or use some logic is because a cardio exercise does not have any sets, reps or weight. They are usually a time based exercise. Whereas, its the other way around for strength training. The user will want to track their sets, reps, and weight, and not how long it took them to perform the exercise. The decision was made to keep them all in the same table because it was easier to implement. Both ways would need some logic at either the inputing into the database end or the extracting end. The logic that was used in the view controller for showing the fitness log was very simple. Thereiss a foreach loop that prints out the information and if the type was equal to cardio then it would print out the format ``Activity - time'', for example ``Cycling - 120 mins'', and if it was strength it would print out ``Activity - sets*reps @ weight'', for example ``Bench press - 3*6 @ 160 lbs''. There is also some logic in the controller that groups the entries by date, so that all the entries for that day will be grouped together.\\

The application would have suggestions for exercises activities. This was for the same reason has having the drop down menu on type, to add consistency to the inputs and throughout the records in the database. Originally, the suggestions were hardcoded into the HTML using the datalist attribute in HTML5 but then a better solution occurred. Having the list hardcoded in to the HTML meant that it was hard to update and keep on top off. Also, what happens if the user did something that was not on the list? If they did that again, what if they inputed it without capitals this time? While changing from capitalised to no capitalised will not break the application, it is better to have everything in the same format. The solution to this problem was to build the datalist from previous exercises the user has completed. This way, if the user has does a certain exercise repeatedly that was not on out list, they will still get the autocomplete function.\\

Once the fitness long was done, the date card could be worked on. At first, the date card was just going to display the current date but the box looked very empty and out of place. To add motivation to the card, a ``time since last gym visit'' was added to this card. This would work in two way.

\begin{enumerate}
\item Motivate them to keep this time down to as little as possible by getting into the gym as often as they could.
\item Motivate them to get back into the gym after a long break by reminding them that they have not been in a long time.
\end{enumerate}

Using Rails today Date.current() function to get the current date and the Created\_at() date from the last fitness log entry from the current user, the application was able to figure out how long it had been since the users last gym visit. Rails also has another great function for this which is distance\_of\_time\_in\_words which takes in two date functions and prints out the distance is real words. For example: less than a minute since your last visit to the gym. or 5 days since your last visit to the gym..\\

After the date card, there was only one feature left to implement. This was the goals feature. Goals was a table that stored two values; the goal and complete. Goal was a string and was what the goal was, and complete was boolean. Goals are shown on the dashboard and can be inputed from the goals\_user\_path in the Rails application. Goals was not a very hard feature to implement. It was simply just one form that created the element and then a list the showed all the goals with a checkbox to check the goals off. Where it got difficult was with AJAX. I wanted the goals to be updated using AJAX, both inputing the goal and checking the goal off. When using AJAX to input the data, I was running into all sort of trouble. At first, it would input the goal multiple times, and then it would not update the last properly when the goal at been input. The decision was to move this to a could have priority. As for checking the goals off, the AJAX works really well. The user will check the box, the goal will then turn red and have strikethrough. After a second the goal will fade and update the record by setting complete to true. Currently, there is no way to uncheck the goal and get it back, the user will have to input. The completed goals are shown below the current goals and they also display their completed on date. With the way the grid works to make the website responsive, on the goals page it will put the first goals card above the input card. This will cause a big problem if the user has a lot of completed goals. To fix this problem, the list will be hidden when the display size is under 650 pixel and a jQuery function will be added to the display this and hide it again.\\

Now that all the main features are added and a working prototype is complete, all that needs doing now is tidying up. The development stage was still a learning process, so a lot of corners were cut. Mainly on aspects like styling and the feel of the website. So now development will continue by tidying up the lose ends of the application with things like, fixing the responsiveness of the website so that it completely mobile friendly, and making sure the flashes show when the user submits by AJAX.\\

\subsection{Clean up}
Once all of all the main features were implemented, a clean up took place. This meant doing things like catching bugs and fixing them that the testing did not pick up, making sure the correct flash displayed with the correct styling, and making sure that the website was accessible from all devices. Most of these had already been picked up during development so there was not a lot to do when it came to cleaning up. The main problem was the flashes. If the form was submitted through AJAX, then the flash would not show, but it would show on the next reload. This was fixed by moving the flash over to a partial and rendering the partial at the top of the page, and then when the AJAX javascript was called, it would update the flash and any other part of the webpage that needed to be dynamically updated. This also solved another problem of having a lot of repeated code. The way to display a flash is the same on every page, and it was repeated on almost every page. Moving it over to partial cut down the code per page.\\

\subsection{Deployment}
\label{sec:deployment}
Deployment of the web application was done through a service called Heroku. It offers a free hosting services for small application but will automatically scale up when demand for the website rises. This was perfect for the application as it was easy to get a prototype on the web quickly but if demand for the website rose then Heroku would scale up my application to match the demand. It was also chosen for its ease of use. It ties in well with Git and just creates a new remote in your local repository to push to. It will thens detect what type of application is being deployed, a Rails application in this case, and do all the setting up necessary to a Rails application. The only setup needed on our end was a few changes to the gem file. Adding a production and development group to switch between a MySQL \citep{mysql:1995} for local testing and PostgrepSQL \citep{postgres:1995} database for Heroku, and adding the Git remote which was made simple with the Heroku tool belt. Heroku also has the option to allow to assign your own domain to it.\\

Other options were to deploy to a virtual Private server using the Capistrano gem \citep{capistrano:2013}. This was the original idea but after discovering Heroku it seemed slightly overkill. Also, with Ruby applications, dependences have to match up, other wise your application will not run. While you can force gem versions in the gem file, Heroku manages all that for you.
