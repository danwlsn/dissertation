\section{Introduction}
This chapter will discuss the development stage of the production of the progress monitoring web application. It will cover a number of topics, from development tools used during this stage to development methods uses whilst building this application. It will also provide a step-by-step walk-through of the building process highlighting problems and how they were overcome.\\

\section{Development Log}
Development began ahead of schedule because designs were already done. Even though not all the designs had been done, the essentials were complete, it was only separate pages that were missing. The colour scheme, font choice, and general feel were all there so development began with the building of the static HTML. Using Grunt \citep{grunt:2013} and sublime made getting out a static site very quick and easy. This stage did not take as long as I had originally planned. It was done within three days, where as originally it was to take two weeks. However, as design has not being fully completed, what is commonly known as designing in the browser took place. This is where a rough idea of what the page is to look like is in the developer head and they just design it in HTML and CSS \nomenclature{CSS}{Cascading Stylesheets} straight away, without going through the step by step process of wire framing and mock ups. While this is not a good idea on large scale project, the minimalist design that the application was adopting made it easier to design in the browser than to draw wireframes and create mock ups.\\

Once the static site had been generated and the designs had been finalised it was straight into Rails development. The develop was split up into features and each feature was implemented separate. This allowed deadlines to be made so it was easy to track the progress and see if development was on track. The features that were split up were;

\begin{enumerate}
\item A user system with the ability to create a new user and login and out
\item Weight tracking, for both current and goal weights
\item Fitness log
\item Goal tracking
\end{enumerate}

\noindent
Once these deadlines were confirmed, development could properly begin.\\

Not much knowledge was known about Ruby on Rails before development, other than some basic syntax and that it is an MVC \nomenclature{MVC}{Model View Controller} framework. So at first, the approach was to learn and build at the same time. This lead to two outcomes and the first problem; it was very slow and the code was getting sloppy. This type of development style did not last very long when development came to a standstill when trying to implement the weight tracking. The decision was made to halt development and take the time to learn some Rails.\\

Two main resources were used for learning rails. The first one was a tutorial by Michael Hartl \citep{michael:2013}. This tutorial took you through making a Twitter \citep{twitter:2006} clone. It was useful because it went through how to create a authentication/authorisation system, create relationships between the user and other models, and also some test driven development. The second was the Rails guides \citep{guides:2013}. These covered pretty much all parts of Rails so they were referred to as and when there was a problem that could not be solved by referring to the documentation. The Rails Documentation was also referred to a lot during development.\\

After a firm understanding of Rails was gained, development could continue. The downside to this break meant that development was now far behind schedule. As development went on though, it caught itself up. The learning break was worth it because development began to speed up and the code that was being produced was to a higher standard.\\

So far, only the user system had been implemented and it was time to move on to the weight tracking. This was where the problem of not knowing enough Rails to continue arose, which was solved with taking the time to learn it instead of learning as development went on. So when it was time to come back to it, all the weight tracking code that was used prior to learning Rails was removed. This was made easy with Git. Git allows you to reset changed to a certain commit. The code was rolled back to where the user system was just finished and so was the Rails database. For the weight tracking, two separate models were used. Originally, the goal weight was going to be inside the user model but the decision was made to split it off so that it could possibly used for future analysis. For example; plotting a graph for both the users weight and their goal weights against time so they will be able to see when they hit their goals. This also led to splitting up the goal weight and the current weight into tables. Another factor into this was the thought that user will be updating their current weight much more than their goal weight. So to have them in the same table would lead to multiple duplicate goal weights. These weights were to be shown on the dashboard and updated through a different page. In the original design, there was going to be a little graph under where the weights are displayed on the dashboard. This idea was removed because of how small the graph would be. It was moved to the weight input page so that it could be a lot bigger and the user would be able to gain more information from it. The weight input screen was kept really simple. It has two input boxes and two submit buttons, one for the goal weight and one for the current. Rails allows for very simple AJAX \nomenclature{AJAX}{Asynchronous JavaScript and XML} integration with forms. AJAX allows the user to update the database without having to leave the current page. This will allow the user to update their weights and then consult the graph without having to load the page again. It will be a great help on mobiles where the data connection may not be great.\\

Once the weight tracking was implemented it was on to the next feature which is the fitness log. The fitness log is its own table which consists of six fields:

\begin{enumerate}
\item Activity - The name of the exercise
\item Type - What type of exercise (strength, cardio)
\item Time - How long the user spent doing the exercise
\item Reps - How many repetitions the user did
\item Sets - How many sets the user did
\item Weight - How heavy the weight was
\end{enumerate}

There are two main types of exercises; strength and cardio. There were two options when it came to storing this information. Option one was to have three tables; fitness log, cardio, and strength. The fitness log would just store the user's ID and the ID of either a cardio entry or a strength entry. Or option two, which is to have them all in one table and use some logic in the controller and view to determine what to do with the data dependant upon whether it is a strength exercise or a cardio exercise. The reason for needing to either split them up or use some logic is because a cardio exercise does not have any sets, reps or weight. They are usually a time based exercise. Whereas, it is the other way around for strength training. The user will want to track their sets, reps, and weight, and not how long it took them to perform the exercise. The decision was made to keep them all in the same table because it was easier to implement. Both ways would need some logic at either the inputing into the database end or the extracting end. The logic that was used in the view controller for showing the fitness log was very simple. There is a foreach loop that prints out the information and if the type was equal to cardio then it would print out the format ``Activity - time'', for example ``Cycling - 120 mins'', and if it was strength it would print out ``Activity - sets*reps @ weight'', for example ``Bench press - 3*6 @ 160 lbs''. There is also some logic in the controller that groups the entries by date, so that all the entries for that day will be grouped together.\\

The application would have suggestions for exercises activities. This was for the same reason as having the drop down menu on type, to add consistency to the inputs and throughout the records in the database. Originally, the suggestions were hardcoded into the HTML using the datalist attribute in HTML5 but then a better solution occurred. Having the list hardcoded in to the HTML meant that it was hard to update and keep on top off. Also, what happens if the user did something that was not on the list? If they did that again, what if they input it without capital letters this time? Whilst changing from capitalised to non-capitalised will not break the application, it is better to have everything in the same format. The solution to this problem was to build the datalist from previous exercises the user has completed. This way, if the user has does a certain exercise repeatedly that was not on our list, they will still get the autocomplete function.\\

As well as showing a list of all of the exercises that the user had completed that day, the application will need to show the users progressing through their time using Recur as this was one of the main goals to keep the user motivated by showing them their progression. Three charts were added to the log view of the website to show their progression on the three main compound weight lifting exercises; the bench press, the deadlift, and the squat. The charts were added using highchart.js \citep{highcharts:2009}. A helper gem called LazyHighCharts \citep{lhc:2010} was used so that the chart could be built in the controller of the application instead of being built in JavaScript in the view of the application. Using the gem made the code a lot easier to manage and change.\\

Once the fitness log was completed, the date card could be worked upon. At first, the date card was just going to display the current date but the box looked very empty and out of place. To add motivation to the card, a ``time since last gym visit'' was added to this card. This would work in two ways.

\begin{enumerate}
\item Motivate them to keep this time down to as little as possible by getting into the gym as often as they could.
\item Motivate them to get back into the gym after a long break by reminding them that they have not been in a long time.
\end{enumerate}

Using Rails today \lstinline{Date.current()} function to get the current date and the \lstinline{Created_at()} date from the last fitness log entry from the current user, the application was able to figure out how long it had been since the users last gym visit. Rails also has another great function for this which is \lstinline{distance_of_time_in_words()} which takes in two date functions and prints out the distance is real words. For example: ``less than a minute since your last visit to the gym. or 5 days since your last visit to the gym.''.\\

After the date card, there was only one feature left to implement. This was the goals feature. Goals was a table that stored two values; the goal and complete. Goal was a string and was what the goal was, and complete was boolean. Goals are shown on the dashboard and can be inputed from the \lstinline{goals_user_path(current_user)} in the Rails application. Goals was not a very hard feature to implement. It was simply just one form that created the element and then a list the showed all the goals with a checkbox to check the goals off. Where it got difficult was with AJAX. The goals needed to be updated through AJAX as to not have to refresh the page when a goal is checked off. When using AJAX to input the data for the goal, it was throwing a lot of errors. At first, it would input the goal multiple times, and then it would not update the list properly when the goal at been input. The decision was made to move this to a could have priority. As for checking the goals off, the AJAX works really well. The user will check the box, the goal will then turn red and have strikethrough. After a second the goal will fade and update the record by setting complete to true. Currently, there is no way to uncheck the goal and get it back, the user will have to input. The completed goals are shown below the current goals and they also display their completed on date. With the way the grid works to make the website responsive, on the goals page it will put the first goals card above the input card. This will cause a big problem if the user has a lot of completed goals. To fix this problem, the list will be hidden when the display size is under 650 pixel and a jQuery function will be added to the display this and hide it again.\\

Now that all the main features are added and a working prototype is complete, all that needs doing now is tidying up. The development stage was still a learning process, so a lot of corners were cut. Mainly on aspects like styling and the feel of the website. So now development will continue by tidying up the lose ends of the application with tasks such as, fixing the responsiveness of the website so that it completely mobile friendly, and making sure the flashes show when the user submits by AJAX.\\

After everything was done, it was apparent that there was no way to analysis the data as an admin. This was resolved by adding an access attribute to the user, that would default to zero. If the access of a user was changed to one, then they would have access to the admin panel. The admin is able to see a list of all the users, along with their current and goals weights, how many goals they have against how many they have completed, how many times they have updated their fitness log, and when they last updated their fitness log. They will also be able to view user's pages but not update their information. \\

\section{Clean up}
Once all of the main features were implemented, a clean up took place. This meant that actions such as catching bugs and fixing them that the testing did not pick up, making sure the correct flash displayed with the correct styling, and making sure that the website was accessible from all devices. Most of these had already been picked up during development so there was not a lot to do when it came to cleaning up. The main problem was the flashes. If the form was submitted through AJAX, then the flash would not show, but it would show on the next reload. This was fixed by moving the flash over to a partial and rendering the partial at the top of the page, and then when the AJAX javascript was called, it would update the flash and any other part of the webpage that needed to be dynamically updated. This also solved another problem of having a lot of repeated code. The way to display a flash is the same on every page, and it was repeated on almost every page. Moving it over to partial cut down the code per page.\\

\section{Optimisation}
Optimisation is a big part of today's web industry. With a lot of people browsing the web from their mobiles, their download speeds are slower than broadband speeds. They also have data caps which restrict the amount of data one user can download in a month. There are certain steps that can be taking to reduce the time it takes for a user to load up the webpage on their mobile devices. The first way we can do this is by manipulating the JavaScript and CSS files. HTTP \nomenclature{HTTP}{HyperText Transfer Protocol} request will slow down the page the load time so we can concatenate the JavaScript and CSS files to reduce the number of HTTP requests we are calling per page. We can remove all of the unnecessary whitespace from this files. This process is called minification. Using both concatenation and minifcation of files, you stand to reduce a large chunk of requests from your website, improving your load time. Other options include optimising your images. Images are the biggest item to load on webpages, ranging from kilobytes to a few megabytes each. There are lots of tools to use for optimising your images. ImageOptim \citep{imageoptim:2014} is what was used for optimising the images. Because not many images are used it wasn't necessary to go through all of the image optimisation steps. ImageOptim gave enough results to justify not going further with image optimisation.\\


\section{Deployment}
\label{sec:deployment}
Deployment of the web application was done through a service called Heroku. It offers free hosting services for small applications but will automatically scale up when demand for the website rises. This was perfect for the application as it was easy to get a prototype on the web quickly but if demand for the website rose then Heroku would scale up my application to match the demand. It was also chosen for its ease of use. It ties in well with Git and creates a new remote in your local repository to push to. It will then detect what type of application is being deployed, a Rails application in this case, and do all the setting up necessary to a Rails application. The only setup needed on our end was a few changes to the gem file. Adding a production and development group to switch between a MySQL \citep{mysql:1995} for local testing and PostgrepSQL \citep{postgres:1995} database for Heroku, and adding the Git remote which was made simple with the Heroku tool belt. Heroku also has the option to allow to assign your own domain to it.\\

Other options were to deploy to a virtual Private server using the Capistrano gem \citep{capistrano:2013}. This was the original idea but after discovering Heroku it seemed unnecessary. Also, with Ruby applications, dependences have to match up, otherwise your application will not run. While you can force gem versions in the gem file, Heroku manages all that for you.

\section{Conclusion}
This chapter discussed the importance of having an understanding of the tools, languages, and frameworks used before undertaking the project. Not knowing enough about the framework that was used caused major delays in the development stage. It also discussed the importance of optimisation. Especially in the case of optimising assets for mobile use. It also discussed the options for deploying the application to the internet, and the pros and cons between the two main options. Deploying to a service, like Heroku, is much easy than setting up a virtual private server. Whilst being easy it can also incur more costs.